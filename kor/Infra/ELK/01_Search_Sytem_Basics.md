# Search System Basics

> 검색 시스템 이해하기
>
> Reference: [책] 엘라스틱서치 실무 가이드

<br>

<br>

## 1. 검색 시스템의 이해

<br>

### 1-1. 검색 시스템이란?

: 검색 서비스는 `검색 엔진`, `검색 시스템`, `검색 서비스` 라는 이름으로 불리운다

- **검색 엔진 (Search Engine)**
  - Web에서 정보를 수집해 검색 결과를 제공하는 프로그램
  - 검색 결과로 제공되는 data의 특성에 따라 구현 형태가 각각 달라진다
- **검색 시스템 (Search System)**
  - 대용량 data를 기반으로 **신뢰성** 있는 검색 결과를 제공하기 위해 `검색 엔진`을 기반으로 구축된 system을 통칭한다
  - `수집기`를 이용해 방대한 data를 **수집**하고,
    - 이것을 다수의 `검색 엔진` 을 이용해 **색인**하고,
    - 검색 결과를 `UI`로 제공한다
  - system 내부의 **정책**에 따라 **관련도**가 높은 문서를 검색 결과의 **상위에 배치**할 수 있으며,
    - 특정 `field`나 `문서`에 **가중치**를 둬서 검색의 **정확도**를 높일 수 있다

- **검색 서비스 (Search Service)**
  - `검색 엔진`을 기반으로 구축한 `검색 시스템`을 활용해 검색 결과를 service로 제공한다

```
검색 서비스 > 검색 시스템 > 검색 엔진
```

<br>

<br>

### 1-2. 검색 시스템의 구성 요소

: 검색 시스템은 정보를 **수집**하는 **수집기**, 수집한 data를 **저장**하는 **스토리지**, 수집한 data를 검색에 적절한 형태로 **변환**하는 **색인기**, 색인된 data에서 일치하는 문서를 **찾는** **검색기**로 구성된다.

<br>

#### 수집기

- web stie, blog, cafe 등에서 필요한 program
- `crawler`, `spider`, `worms`, `web robot` 등으로도 불린다
- file, database, web page 등 web 상의 대부분의 정보가 수집 대상이다
- file의 경우 `수집기`가 file 이름, file 내용, file 경로 등의 정보를 수집하고 **저장**하면 `검색 엔진`이 저장된 정보를 **검색** 하고, 사용자의 질의에 답한다

<br>

#### 스토리지

- database에서 data를 저장하는 물리적인 저장소다
- 검색 엔진은 **색인**한 data를 storage에 보관한다

<br>

#### 색인기

- 검색 엔진이 수집한 정보에서 사용자 질의와 일치하는 정보를 찾으려면 수집된 data를 `검색 가능한 구조`로 **가공**하고, **저장**해야 하는데 그 역할을 하는 것이 `색인기`다
- 색인기는 다양한 **형태소 분석기**를 조합해 정보에서 `의미 있는 용어`를 **추출**하고, 검색에 유리한 **역색인 구조**로 data를 저장한다

<br>

#### 검색기

- 사용자의 질의를 입력받아 색인기에서 저장한 역색인 구조에서 **일치하는 문서**를 찾아 결과로 반환한다
- 질의와 문서가 일치하는지는 **유사도 기반**의 검색 순위 알고리즈으로 판단한다
- 검색기 또한 색인기와 마찬가지로 **형태소 분석기**를 이용해 사용자 질의에서 유의미한 용어를 추출해 검색한다
  - 따라서 사용하는 형태소 분석기에 따라 검색 품질이 달라진다!

<br><br>

### 1-3. 관계형 데이터베이스와의 차이점

- 검색 엔진과 관계형 데이터베이스(RDBMS)는 모두 질의와 일치하는 data를 찾아 사용자에게 제공한다는 점에서 유사점이 많다
- 하지만 관계형 데이터베이스로 검색 기능을 제공하는 데는 많은 문제점이 있다

<br>

#### 관계형 데이터베이스

- Database는 data를 통합 관리하는 data의 집합이다
  - 저장 방식에 따라 크게 **관계형** 또는 **계층형** database로 나뉜다
- 모든 data는 **중복을 제거**하고, **정형 데이터**로 **구조화**해 행과 열로 구성된 table에 저장된다
- SQL문을 이용해 원하는 정보의 검색이 가능한데, text matching을 통한 단순한 검색만 가능하다
  - 즉, text를 여러 단어로 변형하거나 여러 개의 동의어나 유의어를 활용한 검색은 불가능하다

<br>

#### 검색엔진

- 검색엔진은 database에서는 불가능한 비정형 data를 **색인**하고 **검색**할 수 있다
- **형태소 분석**을 통해 사람이 구사하는 **자연어의 처리**가 가능하고, **역색인 구조**를 바탕으로 빠른 검색 속도를 보장한다

<br>

#### ElasticSearch와 RDBMS의 주요 개념 비교

| 엘라스틱서치 | 관계형 데이터베이스 |
| ------------ | ------------------- |
| Index        | Database            |
| Shard        | Partition           |
| Type         | Table               |
| Document     | Row                 |
| Field        | Column              |
| Mapping      | Schema              |
| Query DSL    | SQL                 |

<br>

<br>

## 2. 검색 시스템과 엘리스틱서치

- 요즘에는 대량의 data를 빠르게 검색하기 위해 **NoSQL(No Structed Query Language)**을 많이 사용한다
- 엘라스틱서치도 NoSQL의 일종으로서 **분류**가 가능하고 **분산 처리**를 통해 실시간에 준하는 **빠른 검색**이 가능하다
- 기존 database로는 처리하기 어려운 `대량의 비정형 data`도 검색할 수 있으며, **전문 검색 (Full Text)**과 **구조 검색** 모둘를 지원한다
- 기본적으로는 검색 엔진이지만, `MongoDB`나 `Hbase`처럼 엘라스틱서치를 **대용량 스토리지**로도 활용할 수 있다

<br>

### 2-1. 엘라스틱서치가 강력한 이유

<br>

#### 1. 오픈소스 검색 엔진

- ElasticSearch는 Apache 재단의 Lucene을 기반으로 개발된 `open source` 검색 엔진이다
  - 따라서 전 세계에서 수많은 사람들이 사용하고 있으며, bug가 발생할 경우에도 대부분 빠르게 해결된다

<br>

#### 2. 전문 검색

- `PostgreSQL`, `MongoDB` 같은 대부분의 database는 기본 쿼리 및 색인 구조의 한계로 인해 기본적인 **text 검색 기능만을 제공**한다
  - 하지만 ElasticSearch는 좀 더 고차원적인 **전문 검색(Full Text)**이 가능하다
- **전문 검색**이란 내용 전체를 색인해서 `특정 단어`가 포함된 문서를 검색하는 것을 말한다
  - 기존의 RDBMS는 전문 검색에 적합하지 않지만 ElasticSearch는 다양한 기능별, 언어별 plugin을 조합해 빠르게 검색할 수 있다

<br>

#### 3. 통계 분석

- 비정형 log data를 수집하고 한곳에 모아 **통계 분석**을 할 수 있다
- ElasticSearch와 Kibana를 연동하면 **실시간**으로 쌓이는 log를 **시각화**하고 **분석**할 수 있다

<br>

#### 4. Schemaless

- database는 **schema**라는 구조에 따라 data를 **정합한 형태**로 **변경**해서 저장하고 관리한다
  - 반면 ElasticSearch는 **정형화되지 않은 다양한 형태의 문서**도 자동으로 **색인**하고 **검색**할 수 있다

<br>

#### 5. RESTful API

- ElasticSearch는 **HTTP 기반의 RESTful API**를 지원하고 요청뿐만 아니라 응답에도 `JSON 형식`을 사용하기 때문에 개발 언어, OS, system에 관계 없이 다른 기종의 platform에서도 이용 가능하다

<br>

#### 6. Multi-tenancy

- 서로 상이한 index일지라도 검색할 `field명`만 같으면 **여러 개의 index를 한번에 조회**할 수 있다
  - 이를 이용해 multi-tenancy 기능을 제공할 수 있다

<br>

#### 7. Document-Oriented

- 여러 개층의 data를 `JSON 형식`의 **구조화된 문서**로 index에 저장할 수 있다
- **계층 구조**로 문서도 **한 번의 쿼리로 쉽게 조회**할 수 있다

<br>

#### 8. 역색인 (Inverted Index)

- Lucene 기반의 검색 엔진이기 때문에 역색인을 지원한다
  - 여기서 역색인은 종이책의 마지막 페이지에서 제공하는 색인 페이지와 비슷하게 제공되는 특수한 데이터 구조다
- 만약 "검색 엔진" 이라는 단어가 포함된 모든 문서를 찾아야 할 때, 일반적으로는 처음부터 끝까지 모든 문서를 읽어야 원하는 결과를 얻을 수 있을 것이다
  - 하지만 역색인 구조는 **해당 단어**만 찾으면 **단어가 포함된 문서의 위치**를 알 수 있기 때문에 빠르게 찾을 수 있다

<br>

#### 9. 확장성과 가용성

- ElasticSearch를 **분산 구성**해서 **확장**한다면 대량의 문서를 좀 더 효율적으로 처리할 수 있다
- 분산 환경에서 data는 `shard`라는 작은 단위로 나뉘어 제공되며, `index`를 만들 때마다 **shard의 수를 조절**할 수 있다
  - 이를 통해 data의 **종류**와 **성격**에 따라 data를 **분산**해서 빠르게 처리할 수 있따

<br>

<br>

### 2-2. 엘라스틱서치의 약점

1. **"실시간"**이 아니다
   - 일반적으로 색인 된 data는 통상적으로 1초 뒤에나 검색이 가능해진다
   - 색인된 data는 내부적으로 `commit`과 `flush` 같은 복잡한 과정을 거치기 때문에 실시간이 아니다
     - 엄밀히 따지자면 준 실시간(Near Realtime)이라고 할 수 있다
2. **Transaction**과 **rollback** 기능을 제공하지 않는다
   - ElasticSearch는 기본적으로 `분산 시스템`으로 구성된다
   - 전체적인 cluster의 성능 향상을 위해 system적으로 **비용 소모가 큰** rollback과 transaction을 지원하지 않기 때문에 최악의 경우 **data 손실**의 위험이 있다
3. Data의 **update**를 제공하지 않는다
   - 엄밀히 말하자면 ElasticSearch는 update 명령이 요청될 경우, 기존 문서를 **삭제**하고 변경된 내용으로 **새로운 문서를 생성**하는 방식을 사용한다
     - 이러한 이유로 단순 update에 비해 상대적으로 큰 비용이 발생한다
       - But, **immutable**이라는 이점을 취할 수 있기 때문에 큰 단점은 아니다!
